# Service containers
name: Redis container example
on: push

jobs:
  container-job:
    runs-on: ubuntu-latest
    container: node 16-bullseye # Notice the container job specifies container
    services: # You can use the services keyword to create service containers that are part of a job in your workflow.
      redis:
        image: redis

  runner-job:
    runs-on: ubuntu-latest
    services: # Notice the runner job specifies no container
      redis:
        image: redis
        ports:
          6379:6379 # For a runner job you need to map the ports.

  build:
    services:
      redis:
        # Docker Hub Image
        image: redis
        ports:
          6379:6379
        credentials: # You can specify credentials for your service containers in case you need to authenticate with an image registry
          username: ${{ secrets.dockerhub_username }}
          password: ${{ secrets.dockerhub_password }}
      db:
        # Private registry image
        image: ghcr.io/octocat/testdb:latest
        credentials:
          username: ${{ github.repository_owner }}
          password: ${{ secrets.ghcr_password}}
  
  container-job:
    runs-on: ubuntu-latest
    container: node 10.18-jessie # Running a Postgres server as a service container
    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          5432:5432
    steps: # Connecting the Postgres service container in a step
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install dependencies
        run: npm ci
      - name: Connect to PostgreSQL
        run: node client.js
        env:
          POSTGRES_HOST: postgres
          POSTGRES_PORT: 5432